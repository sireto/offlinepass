(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('jotai/react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'jotai/react'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.jotaiDevtools = {}, global.React, global.react));
})(this, (function (exports, react$1, react) { 'use strict';

  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var atomToPrintable$1 = function atomToPrintable(atom) {
    return atom.debugLabel || atom.toString();
  };
  var stateToPrintable = function stateToPrintable(_ref) {
    var store = _ref[0],
      atoms = _ref[1];
    return Object.fromEntries(atoms.flatMap(function (atom) {
      var mounted = store.dev_get_mounted == null ? void 0 : store.dev_get_mounted(atom);
      if (!mounted) {
        return [];
      }
      var dependents = mounted.t;
      var atomState = (store.dev_get_atom_state == null ? void 0 : store.dev_get_atom_state(atom)) || {};
      return [[atomToPrintable$1(atom), _extends({}, 'e' in atomState && {
        error: atomState.e
      }, 'v' in atomState && {
        value: atomState.v
      }, {
        dependents: Array.from(dependents).map(atomToPrintable$1)
      })]];
    }));
  };
  var useAtomsDebugValue = function useAtomsDebugValue(options) {
    var _options$enabled;
    var enabled = (_options$enabled = options == null ? void 0 : options.enabled) != null ? _options$enabled : true;
    var store = react.useStore(options);
    var _useState = react$1.useState([]),
      atoms = _useState[0],
      setAtoms = _useState[1];
    react$1.useEffect(function () {
      if (!enabled) {
        return;
      }
      var callback = function callback() {
        setAtoms(Array.from((store.dev_get_mounted_atoms == null ? void 0 : store.dev_get_mounted_atoms()) || []));
      };
      var unsubscribe = store.dev_subscribe_state == null ? void 0 : store.dev_subscribe_state(callback);
      callback();
      return unsubscribe;
    }, [enabled, store]);
    react$1.useDebugValue([store, atoms], stateToPrintable);
  };

  function useAtomDevtools(anAtom, options) {
    var _ref = options || {},
      enabled = _ref.enabled,
      name = _ref.name;
    var extension;
    try {
      extension = (enabled != null ? enabled : true) && window.__REDUX_DEVTOOLS_EXTENSION__;
    } catch (_unused) {}
    if (!extension) {
      if (enabled) {
        console.warn('Please install/enable Redux devtools extension');
      }
    }
    var _useAtom = react.useAtom(anAtom),
      value = _useAtom[0],
      setValue = _useAtom[1];
    var lastValue = react$1.useRef(value);
    var isTimeTraveling = react$1.useRef(false);
    var devtools = react$1.useRef();
    var atomName = name || anAtom.debugLabel || anAtom.toString();
    react$1.useEffect(function () {
      if (!extension) {
        return;
      }
      var setValueIfWritable = function setValueIfWritable(value) {
        if (typeof setValue === 'function') {
          setValue(value);
          return;
        }
        console.warn('[Warn] you cannot do write operations (Time-travelling, etc) in read-only atoms\n', anAtom);
      };
      devtools.current = extension.connect({
        name: atomName
      });
      var unsubscribe = devtools.current.subscribe(function (message) {
        var _message$payload3, _message$payload4;
        if (message.type === 'ACTION' && message.payload) {
          try {
            setValueIfWritable(JSON.parse(message.payload));
          } catch (e) {
            console.error('please dispatch a serializable value that JSON.parse() support\n', e);
          }
        } else if (message.type === 'DISPATCH' && message.state) {
          var _message$payload, _message$payload2;
          if (((_message$payload = message.payload) == null ? void 0 : _message$payload.type) === 'JUMP_TO_ACTION' || ((_message$payload2 = message.payload) == null ? void 0 : _message$payload2.type) === 'JUMP_TO_STATE') {
            isTimeTraveling.current = true;
            setValueIfWritable(JSON.parse(message.state));
          }
        } else if (message.type === 'DISPATCH' && ((_message$payload3 = message.payload) == null ? void 0 : _message$payload3.type) === 'COMMIT') {
          var _devtools$current;
          (_devtools$current = devtools.current) == null ? void 0 : _devtools$current.init(lastValue.current);
        } else if (message.type === 'DISPATCH' && ((_message$payload4 = message.payload) == null ? void 0 : _message$payload4.type) === 'IMPORT_STATE') {
          var _message$payload$next;
          var computedStates = ((_message$payload$next = message.payload.nextLiftedState) == null ? void 0 : _message$payload$next.computedStates) || [];
          computedStates.forEach(function (_ref2, index) {
            var state = _ref2.state;
            if (index === 0) {
              var _devtools$current2;
              (_devtools$current2 = devtools.current) == null ? void 0 : _devtools$current2.init(state);
            } else {
              setValueIfWritable(state);
            }
          });
        }
      });
      devtools.current.shouldInit = true;
      return unsubscribe;
    }, [anAtom, extension, atomName, setValue]);
    react$1.useEffect(function () {
      if (!devtools.current) {
        return;
      }
      lastValue.current = value;
      if (devtools.current.shouldInit) {
        devtools.current.init(value);
        devtools.current.shouldInit = false;
      } else if (isTimeTraveling.current) {
        isTimeTraveling.current = false;
      } else {
        devtools.current.send(atomName + " - " + new Date().toLocaleString(), value);
      }
    }, [anAtom, extension, atomName, value]);
  }

  var isEqualAtomsValues = function isEqualAtomsValues(left, right) {
    return left.size === right.size && Array.from(left).every(function (_ref) {
      var left = _ref[0],
        v = _ref[1];
      return Object.is(right.get(left), v);
    });
  };
  var isEqualAtomsDependents = function isEqualAtomsDependents(left, right) {
    return left.size === right.size && Array.from(left).every(function (_ref2) {
      var a = _ref2[0],
        dLeft = _ref2[1];
      var dRight = right.get(a);
      return dRight && dLeft.size === dRight.size && Array.from(dLeft).every(function (d) {
        return dRight.has(d);
      });
    });
  };
  function useAtomsSnapshot(options) {
    var store = react.useStore(options);
    var _useState = react$1.useState(function () {
        return {
          values: new Map(),
          dependents: new Map()
        };
      }),
      atomsSnapshot = _useState[0],
      setAtomsSnapshot = _useState[1];
    react$1.useEffect(function () {
      if (!store.dev_subscribe_state) return;
      var prevValues = new Map();
      var prevDependents = new Map();
      var callback = function callback() {
        var values = new Map();
        var dependents = new Map();
        for (var _iterator = _createForOfIteratorHelperLoose(store.dev_get_mounted_atoms() || []), _step; !(_step = _iterator()).done;) {
          var atom = _step.value;
          var atomState = store.dev_get_atom_state(atom);
          if (atomState) {
            if ('v' in atomState) {
              values.set(atom, atomState.v);
            }
          }
          var mounted = store.dev_get_mounted(atom);
          if (mounted) {
            dependents.set(atom, mounted.t);
          }
        }
        if (isEqualAtomsValues(prevValues, values) && isEqualAtomsDependents(prevDependents, dependents)) {
          return;
        }
        prevValues = values;
        prevDependents = dependents;
        setAtomsSnapshot({
          values: values,
          dependents: dependents
        });
      };
      var unsubscribe = store.dev_subscribe_state(callback);
      callback();
      return unsubscribe;
    }, [store]);
    return atomsSnapshot;
  }

  function useGotoAtomsSnapshot(options) {
    var store = react.useStore(options);
    return react$1.useCallback(function (snapshot) {
      if (store.dev_restore_atoms) {
        store.dev_restore_atoms(snapshot.values);
      }
    }, [store]);
  }

  var atomToPrintable = function atomToPrintable(atom) {
    return atom.debugLabel ? atom + ":" + atom.debugLabel : "" + atom;
  };
  var getDevtoolsState = function getDevtoolsState(atomsSnapshot) {
    var values = {};
    atomsSnapshot.values.forEach(function (v, atom) {
      values[atomToPrintable(atom)] = v;
    });
    var dependents = {};
    atomsSnapshot.dependents.forEach(function (d, atom) {
      dependents[atomToPrintable(atom)] = Array.from(d).map(atomToPrintable);
    });
    return {
      values: values,
      dependents: dependents
    };
  };
  function useAtomsDevtools(name, options) {
    var _ref = options || {},
      enabled = _ref.enabled;
    var extension;
    try {
      extension = (enabled != null ? enabled : true) && window.__REDUX_DEVTOOLS_EXTENSION__;
    } catch (_unused) {}
    if (!extension) {
      if (enabled) {
        console.warn('Please install/enable Redux devtools extension');
      }
    }
    var atomsSnapshot = useAtomsSnapshot();
    var goToSnapshot = useGotoAtomsSnapshot();
    var isTimeTraveling = react$1.useRef(false);
    var isRecording = react$1.useRef(true);
    var devtools = react$1.useRef();
    var snapshots = react$1.useRef([]);
    react$1.useEffect(function () {
      if (!extension) {
        return;
      }
      var getSnapshotAt = function getSnapshotAt(index) {
        if (index === void 0) {
          index = snapshots.current.length - 1;
        }
        var snapshot = snapshots.current[index >= 0 ? index : 0];
        if (!snapshot) {
          throw new Error('snaphost index out of bounds');
        }
        return snapshot;
      };
      var connection = extension.connect({
        name: name
      });
      var devtoolsUnsubscribe = connection.subscribe(function (message) {
        var _message$payload;
        switch (message.type) {
          case 'DISPATCH':
            switch ((_message$payload = message.payload) == null ? void 0 : _message$payload.type) {
              case 'RESET':
                break;
              case 'COMMIT':
                connection.init(getDevtoolsState(getSnapshotAt()));
                snapshots.current = [];
                break;
              case 'JUMP_TO_ACTION':
              case 'JUMP_TO_STATE':
                isTimeTraveling.current = true;
                goToSnapshot(getSnapshotAt(message.payload.actionId - 1));
                break;
              case 'PAUSE_RECORDING':
                isRecording.current = !isRecording.current;
                break;
            }
        }
      });
      devtools.current = connection;
      devtools.current.shouldInit = true;
      return function () {
        extension.disconnect();
        devtoolsUnsubscribe == null ? void 0 : devtoolsUnsubscribe();
      };
    }, [extension, goToSnapshot, name]);
    react$1.useEffect(function () {
      if (!devtools.current) {
        return;
      }
      if (devtools.current.shouldInit) {
        devtools.current.init(undefined);
        devtools.current.shouldInit = false;
        return;
      }
      if (isTimeTraveling.current) {
        isTimeTraveling.current = false;
      } else if (isRecording.current) {
        snapshots.current.push(atomsSnapshot);
        devtools.current.send({
          type: "" + snapshots.current.length,
          updatedAt: new Date().toLocaleString()
        }, getDevtoolsState(atomsSnapshot));
      }
    }, [atomsSnapshot]);
  }

  exports.useAtomDevtools = useAtomDevtools;
  exports.useAtomsDebugValue = useAtomsDebugValue;
  exports.useAtomsDevtools = useAtomsDevtools;
  exports.useAtomsSnapshot = useAtomsSnapshot;
  exports.useGotoAtomsSnapshot = useGotoAtomsSnapshot;

}));
